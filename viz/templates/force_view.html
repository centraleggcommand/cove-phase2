<!DOCTYPE html>

<!-- Reference http://bl.ocks.org/mbostock/1021841 -->

<meta charset="utf-8">
<style>

</style>

<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.6.min.js"></script>

<script>
// The var FV is a container for global data to be referenced explicitly.
var FV = {};

function initialize() {
    FV.allMice = JSON.parse( '{{ jsonAllMice | safe}}');
    //Reverse the list for popping
    FV.miceGenData = [];
    for (var i=FV.allMice.length -1; i >=0; i--) {
        FV.miceGenData.push( FV.allMice[i]);
    }

    FV.width = 800,
    FV.height = 450;
    FV.fill = d3.scale.category10();
    FV.genFoci = [];
    var segmentSize = FV.width/FV.allMice.length;
    for (var i=0; i < FV.allMice.length; i++) {
        // Calc the midpoint of a segment
        FV.genFoci[i] = { 'x': ((i+1) * segmentSize) - segmentSize/2, 'y': FV.height/2 };
    }
}

function handle_color() {
    var selected = this.value;
    if (selected == "genotype") {
        d3.select("#gene_selector").style("display","inline")
    }
    else {
        d3.select("#gene_selector").style("display","none")
    }
}

function assign_color( d) {
    var grp = FV.sel.options[FV.sel.selectedIndex].value;
    if (grp == "gender") {
        if(d.gender == "F") {
            return "#FF7575";
        }
        else {
            return "#3366FF";
        }
    }
}

initialize();

$(document).ready( function() {
    FV.layoutNodes = [];
    FV.force = d3.layout.force()
            .nodes( FV.layoutNodes )// Show only root generation then add others incrementally.
            .size([FV.width, FV.height])
            .charge(-10)
            .gravity(.1)
            .on("tick", tick)
            .start();

    FV.svg = d3.select("#graph").append("svg")
        .attr("width", FV.width)
        .attr("height", FV.height);

    FV.sel = d3.select("#selectColorGroup")
        .node();
    d3.select("#selectColorGroup").on("change", handle_color);

    FV.all_foci = function() {
        return { 'x': FV.width/2, 'y': FV.height/2 };
    }

    FV.gen_foci = function(o) {
        return { 'x': FV.genFoci[o.generation]['x'], 'y': FV.genFoci[o.generation]['y'] };
    }

    FV.gender_offset = function(o) {
        var x = (o.gender == "F") ? -20 : 20;
        return { 'x': x, 'y': 0};
    }

    FV.genotype_offset = function(o) {

    }

    // Set default function to use when clustering nodes.
    FV.foci_fxn = FV.gen_foci;
    FV.color_offset = FV.gender_offset;

    FV.delayInterval = 2000;

    FV.currGen = FV.miceGenData.pop();
    FV.currGenClass = "gen" + FV.currGen[0].generation;
    FV.interval = setInterval( function() {
        if (FV.currGen.length == 0 && FV.miceGenData.length > 0) {
            FV.currGen = FV.miceGenData.pop();
            FV.currGenClass = "gen" + FV.currGen[0].generation;
            //for (var i=0; i<currGen.length; i++) {
            //    FV.layoutNodes.push(currGen[i]);
            //}
            //FV.force.start();
            //FV.svg.selectAll(".node").data(FV.layoutNodes, get_id)
            //    .enter()
            //    .append("circle")
            //    .attr("cx", function(d) {
            //            var randomNum = Math.random();
            //            randomNum = (randomNum & 1 ? randomNum : -1 * randomNum);
            //            d.x = d.px = FV.genFoci[d.generation]['x'] + (100 * randomNum);
            //            return d.x;
            //    })
            //    .attr("cy", function(d) {
            //            var randomNum = Math.random();
            //            randomNum = randomNum & 1 ? randomNum : -1 * randomNum;
            //            d.y = d.py = FV.genFoci[d.generation]['y'] + (100 * randomNum);
            //            return d.y;
            //    })
            //    .classed("node", "true")
            //    .classed(currGenClass, "true")
            //    .attr("r", 2)
            //    .style("stroke", "rgb(24,24,24)")
            //    .style("stroke-width", "1.0px")
            //    .style("fill", function(d, i) { return assign_color(d); })
            //    .style("opacity", 0.1);
            //d3.selectAll("." + currGenClass).transition().delay( function(d,i) {return i*0.2;})
            //    .duration(800)
            //    .style("opacity","0.9");
        }
        else if (FV.miceGenData.length == 0) {
            clearInterval(FV.interval);
        }
    }, FV.delayInterval);

    d3.select("#btnAll").on("click", function() {
        FV.foci_fxn = FV.all_foci;
        d3.selectAll(".clusterLabel")
            .transition()
            .style("opacity", 1e-6)
            .attr("x", FV.foci_fxn()["x"]);
        FV.force.resume();
    })

    d3.select("#btnGen").on("click", function() {
        FV.foci_fxn = FV.gen_foci;
        d3.selectAll(".clusterLabel")
            .transition()
            .style("opacity","1")
            .attr("x", function(d) {
                return d["x"];
            })
        FV.force.resume();
    })

    function get_id( d) {
        if (d) { return d.mouseId; }
    }

    function add_arrows( node) {

    }

    function tick(e) {
        if (FV.currGen.length == 0) { return; }
        FV.layoutNodes.push(FV.currGen.pop());
        FV.force.start();
        FV.svg.selectAll(".node").data(FV.layoutNodes, get_id)
            .enter()
            .append("circle")
            .attr("cx", function(d) {
                    var randomNum = Math.random();
                    randomNum = (randomNum & 1 ? randomNum : -1 * randomNum);
                    d.x = d.px = FV.genFoci[d.generation]['x'] + (100 * randomNum);
                    return d.x;
            })
            .attr("cy", function(d) {
                    var randomNum = Math.random();
                    randomNum = randomNum & 1 ? randomNum : -1 * randomNum;
                    d.y = d.py = FV.genFoci[d.generation]['y'] + (100 * randomNum);
                    return d.y;
            })
            .classed("node", "true")
            .classed(FV.currGenClass, "true")
            .attr("r", 3)
            .style("stroke", "rgb(24,24,24)")
            .style("stroke-width", "1.0px")
            .style("fill", function(d, i) { return assign_color(d); })
            .style("opacity", 0.1)
            .on("mouseover", function() {
                //undo any previous selection
                d3.select(".hovered")
                    .classed("hovered", false)
                    .style("stroke", "rgb(24,24,24)")
                    .style("stroke-width", "1.0px")
                d3.select(this)
                    .classed("hovered", true)
                    .style( "stroke", "#66FF33")
                    .style("stroke-width", "3px");
                //add_arrows(this);
            });
        d3.selectAll("." + FV.currGenClass).transition().delay( function(d,i) {return i*0.2;})
            .duration(800)
            .style("opacity","1");

        // Push nodes toward their designated focus.
        var nodeSet = FV.svg.selectAll(".node");
        var k = 0.2 * e.alpha;
        nodeSet.each(function(o, i) {
            var target = FV.foci_fxn(o);
            var offset = FV.color_offset(o);
            o.x += (target['x'] + offset['x'] - o.x) * k;
            o.y += (target['y'] + offset['y'] - o.y) * k;
            })
        // Update drawn circle
        nodeSet.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });

        // Stop the simulation when cool enough and add labels
        if (FV.miceGenData.length == 0 && (FV.currGen.length == 0) ) {
            setTimeout( function() {
                FV.force.stop();
                // Add labels for clusters
                // Find approx midpoint of clusters
                FV.clusterMidpoints = [];
                var counter = 0;
                for (var i=0; i < FV.layoutNodes.length; i++) {
                    if (FV.layoutNodes[i].generation == counter) {
                        var offset = FV.color_offset(FV.layoutNodes[i]);
                        FV.clusterMidpoints.push( {'x': FV.layoutNodes[i].x - offset.x, 'y': FV.layoutNodes[i].y - offset.y});
                        counter++;
                        if (counter == FV.genFoci.length) {
                            break;
                        }
                    }
                }
                FV.svg.selectAll(".clusterLabel").data( FV.clusterMidpoints).enter()
                        .append("text")
                        .text( function(d,i) { return "Gen" + i; })
                        .attr("x", function(d) { return d.x; })
                        .attr("y", FV.genFoci[0].y -150)  //make y value the same for all labels
                        .attr("class","clusterLabel")
                        .style("text-anchor", "middle")
                        .style("fill", "#D3D3DD")
                        .style("opacity", "1");

            }, 1000);
        }
    }

});

</script>

<div id="filters">
<table cellspacing="10">
    <tr><td>
        <label>Color Group: </label>
        <select id="selectColorGroup">
            <option value="gender" selected="true">Gender</option>
            <option value="genotype">Genotype</option>
        </select>
        </div>
    </td>
    <td>
        <label>Partition By: </label>
        <button id="btnAll">All</button>
    </td>
    <td>
        <button id="btnGen">Generation</button>
    </td>
    </tr>
    <tr id="gene_selector" style="display:none"><td>
        <label>LEF1</label><br>
        <input type="radio" name="genotype" value="+/-">+/-<br>
        <input type="radio" name="genotype" value="-/-">-/-<br>
        <input type="radio" name="genotype" value="WT">WT<br>
    </td><td>
        <label>RANKL</label><br>
        <input type="radio" name="genotype" value="+/-">+/-<br>
        <input type="radio" name="genotype" value="-/-">-/-<br>
        <input type="radio" name="genotype" value="WT">WT<br>
    </td><td>
        <label>PTHrP</label><br>
        <input type="radio" name="genotype" value="+/-">+/-<br>
        <input type="radio" name="genotype" value="-/-">-/-<br>
        <input type="radio" name="genotype" value="WT">WT<br>
    </td></tr>
</table>
</div>

<div id="graph"></div>

</body>
</html>