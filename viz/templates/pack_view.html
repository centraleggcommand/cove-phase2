<!DOCTYPE html>

<!-- Reference http://bl.ocks.org/mbostock/1021841 -->

<meta charset="utf-8">
<style>

</style>

<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.6.min.js"></script>

<script>

// Allow function currying - copied from "Javascript: The Good Parts" by Crockford
Function.prototype.curry = function() {
    var slice = Array.prototype.slice,
            args = slice.apply(arguments),
            that = this;
    return function() {
        return that.apply(null, args.concat(slice.apply(arguments)));
    };
};

// The var FV is a container for global data to be referenced explicitly.
var FV = {};

// Assign values to the FV.fit_scale function and FV.genFoci positions
function set_scale_foci( nodeLayouts) {
    // Determine the horizontal spacing for each generation based on root node radius.
    for (var i=0; i < nodeLayouts.length; i++) {
        var currGen = nodeLayouts[i];
        for (var j=0; j < currGen.length; j++) {
            if (currGen[j].depth == 0) {
                FV.genFoci[i] = {'radius': currGen[j].r,
                    'x': currGen[j].x,
                    'y': currGen[j].y};
                break;
            }
        }
    }

    // Add diameter of each generation to scale width.
    var totSpan = FV.genFoci.reduce( function( prev, curr, i, array) {
        return prev + curr.radius * 2;
    }, 0)
    // Get max radius to scale the height.
    var maxRadius = FV.genFoci.reduce( function( prev, curr, i, array) {
        return (prev < curr.radius) ? curr.radius : prev;
    }, 0)

    // Create scale function
    var x_scale = d3.scale.linear().domain([0, totSpan]).range([0, FV.width]);
    var y_scale = d3.scale.linear().domain([0, maxRadius*2]).range([0, FV.height]);
    FV.fit_scale = (x_scale(maxRadius) < y_scale(maxRadius)) ? x_scale : y_scale;

    // Assign foci values
    var runningSum = 0; // Keep track of offset from left of graph
    for (var i=0; i < FV.genFoci.length; i++) {
        var scaledRadius = FV.fit_scale(FV.genFoci[i].radius);
        FV.genFoci[i].radius = scaledRadius;
        FV.genFoci[i]['dx'] = runningSum + scaledRadius - FV.genFoci[i].x;
        FV.genFoci[i]['dy'] = 0;
        runningSum += (scaledRadius * 2);
    }

}

function initialize() {
    FV.allMice = JSON.parse( '{{ jsonAllMice | safe}}');
    //The allMice object is an array of arrays for generation data, and element a json object.
    //Convert to format for hierarchical packing (1 level for all objects of a generation).
    //Use separate layout for each generation.
    FV.miceGenData = [];
    for (var i=0; i < FV.allMice.length; i++) {
        FV.miceGenData.push( {'name': 'Gen' + i, 'children': FV.allMice[i]});
    }

    // Mice data format needs to support additional hierarchy such as by gender and litter.
    // Create an object with a field that supplies ordered array of functions to apply to
    // the data in most basic form - grouped by generation.
    FV.formattedData = { // format_fxns are functions that take one parameter - array of raw data objects
                        'format_fxns': [],
                        'miceData': FV.miceGenData,
                        'get_hierarchy': function() {
                            // Recursive helper fxn
                            var that = this;
                            var applyFormat = function( currLevel, format_index) {
                                var innerHierarchy = [];
                                for (var ci=0; ci < currLevel.length; ci++) {
                                    var formattedGroup =
                                        {'name': currLevel[ci].name,
                                         'children': that.format_fxns[format_index]( currLevel[ci].children) };
                                    // A depth first approach in recursion, in which the format_index
                                    // corresponds to depth
                                    if ( (format_index + 1) < that.format_fxns.length) {
                                        // Overwrite children array with grouped version
                                        formattedGroup.children = applyFormat( formattedGroup.children, format_index + 1);
                                    }
                                    innerHierarchy.push( formattedGroup);
                                }
                                return innerHierarchy;
                            };
                            if (this.format_fxns.length == 0) {
                                return this.miceData;
                            }
                            // Recursively apply format
                            return applyFormat( this.miceData, 0);
                        },
                        // The id parameter needs to correlate with DOM checkbox that uses the 'fmt' function
                        'add_format': function( id, fmt) {
                            // Attach the id as an attribute belonging to the fmt function object
                            fmt.id = id;
                            this.format_fxns.push( fmt);
                        },
                        'remove_format': function( id) {
                            this.format_fxns = this.format_fxns.filter( function( elem) { return elem.id != id; });
                        }
    };

    FV.width = 950,
    FV.height = 450;

    FV.genFoci = [];
    // Estimate boundary circle of each generation to assign layout size
    for (var i=0; i < FV.allMice.length; i++) {
        // Calculate circle size based on number of nodes
        var totalArea = 64* FV.allMice[i].length;
        FV.genFoci[i] = {"estimate": Math.sqrt(totalArea) };
    }

    // Use the circle packing layout to calculate node positions for each generation.
    var nodeLayouts = [];
    for (var i=0; i < FV.miceGenData.length; i++) {
        nodeLayouts.push( d3.layout.pack().size([FV.genFoci[i].estimate * 2, FV.height]).padding(10)
                .value( function(d) { return 1; })
                .nodes( FV.miceGenData[i]));
    }

    set_scale_foci( nodeLayouts);

    return nodeLayouts;
}

function handle_color() {
    var selected = this.value;
    if (selected == "genotype") {
        // Show the gene radio button selectors
        d3.select("#geneSelector").style("display","inline")
    }
    else if (selected == "gender") {
        d3.select("#geneSelector").style("display","none")
        update_color( assign_gender_color);
    }
}

function assign_gender_color( d) {
    if(d.gender == "F") {
        return "#FF7575";
    }
    else if (d.gender == "M") {
        return "#3366FF";
    }
    else return "#C0C0C0";
}

// This function is meant to be curried, since the selections should not have to be looked up
// for every node that this function is called for.
function assign_genotype_color( selections, d) {
    var unmatched = "#C0C0C0";
    var match = "#00AA00";
    // Try to eliminate by looking for mismatch with selection values
    if (d.gene1 in selections) {
        if (d.genotype1 != selections[d.gene1]) {
            return unmatched;
        }
    }
    if (d.gene2 in selections) {
        if (d.genotype2 != selections[d.gene2]) {
            return unmatched;
        }
    }
    if (d.gene3 in selections) {
        if (d.genotype3 != selections[d.gene3]) {
            return unmatched;
        }
    }
    return match;
}

// Callback when gene radio button is clicked
function handle_gene() {
    var selections = {};
    var that = this; // 'that' is used for closure
    // The 'this' context here is for element clicked.
    // Make sure the value for the gene is the newly selected checkbox
    if (this.checked == true) {
        selections[this.name] = this.value;
    }
    // Create a dictionary of genes with selected values
    d3.selectAll("#geneSelector input").each( function() {
        // Uncheck a previous gene value
        if (this.checked == true) {
            if ( (this.name == that.name) && (this.value != that.value) ) {
                this.checked = false;
            }
            else selections[this.name] = this.value;
        }
    })
    // For unchecking a checkbox, the selections will not include this element
    update_color( assign_genotype_color.curry( selections));
}

// Callback when user clicks on checkbox to group by gender
function handle_group_gender() {
    if (this.checked == true) {
        FV.formattedData.add_format( "genderCheck", create_gender_format);
        update_view( layout_generations( FV.formattedData.get_hierarchy() ) );
    }
    else {
        FV.formattedData.remove_format( "genderCheck");
        update_view( layout_generations( FV.formattedData.get_hierarchy() ) );
    }
}

// Callback when user clicks on checkbox to group by litter
function handle_group_litter() {
    if (this.checked == true) {
        FV.formattedData.add_format( "litterCheck", create_litter_format);
        update_view( layout_generations( FV.formattedData.get_hierarchy() ) );
    }
    else {
        FV.formattedData.remove_format( "litterCheck");
        update_view( layout_generations( FV.formattedData.get_hierarchy() ) );
    }
}

function create_initial_view( initNodes) {
    FV.svg = d3.select("#graph").append("svg")
            .attr("width", FV.width)
            .attr("height", FV.height);

    //FV.svg.style("opacity", "0.1")
    //        .transition()
    //        .duration(800)
    //        .style("opacity","1");

    // Add event handlers to various view options
    d3.select("#selectColorGroup").on("change", handle_color);
    d3.select("#genderCheck").on("click", handle_group_gender);
    d3.select("#litterCheck").on("click", handle_group_litter);
    d3.selectAll("#geneSelector input").on("click", handle_gene);

    // Use default color selection indicated by DOM dropdown element
    var colorOption = d3.select("#selectColorGroup").node();
    var colorBy = colorOption.options[colorOption.selectedIndex].value;
    var color_fxn;
    if (colorBy == "gender") { color_fxn = assign_gender_color; }
    else if (colorBy == "genotype") { color_fxn = assign_genotype_color;}

    for (var i=0; i < initNodes.length; i++) {
        var genGrp = FV.svg.append("g")
                .attr("id","g" + i)
                .attr("transform", "translate(" + FV.genFoci[i].dx + ", " + FV.genFoci[i].dy + ")" );
        genGrp.selectAll(".gen" + i).data(initNodes[i])
                .enter()
                .append("circle")
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; })
                .attr("r", function(d) { return FV.fit_scale(d.r); })
                .classed("node", "true")
                .classed("gen" + i, "true")
                .style("stroke", "rgb(150,150,150)")
                .style("stroke-width", "1.0px")
                .style("fill", function(d, i) {
                    if (d.depth == 0) { return "rgba(255,255,255,0)"; }
                    else {
                        return color_fxn(d);
                    }
                })
                .on("mouseover", function() {
                    if (d3.select(this).datum().depth != 0) {
                        //undo any previous selection
                        d3.select(".hovered")
                                .classed("hovered", false)
                                .style("stroke", "rgb(150, 150, 150)")
                                .style("stroke-width", "1.0px")
                        d3.select(this)
                                .classed("hovered", true)
                                .style( "stroke", "#66FF33")
                                .style("stroke-width", "3px");
                    }
                });
    }

}

// Format mice data to have hierarchy of generation then gender type
function create_gender_format( rawNodes) {
    // Create additional grouping by gender
    var genderGroup = [];
    genderGroup.push( {'name': 'female',
                       'children': rawNodes.filter( function( elem) { return elem.gender == "F"; })
    });
    genderGroup.push( {'name': 'male',
        'children': rawNodes.filter( function( elem) { return elem.gender == "M"; })
    });
    genderGroup.push( {'name': 'unknown',
        'children': rawNodes.filter( function( elem) { return (elem.gender != "M") && (elem.gender != "F"); })
    });
    return genderGroup;
}

// Format data to have hierarchy of litters unique by motherID, fatherID, and litter number
function create_litter_format( rawNodes) {
    var litterGroup = [];
    // Hold members of each distinct litter in a separate array
    var distinctLitters = {};
    for (var i=0; i < rawNodes.length; i++) {
        var litterId = rawNodes[i].motherId + rawNodes[i].fatherId + rawNodes[i].litter;
        if (distinctLitters[litterId]) {
            distinctLitters[litterId].push(rawNodes[i]);
        }
        else {
            distinctLitters[litterId] = [rawNodes[i]];
        }
    }
    // Create hierarchy format
    var attrib;
    for (attrib in distinctLitters) {
        // Make sure the attribute is not inherited
        if (distinctLitters.hasOwnProperty(attrib) ) {
            litterGroup.push( {'name': attrib, 'children': distinctLitters[attrib]} );
        }
    }
    return litterGroup;
}

// Take an array of objects, with each object representing a generation, and having a children field.
// Return an array of an array of objects that have data for position and size.
function layout_generations( genArray) {
    // Use the circle packing layout to calculate node positions for each generation.
    var nodeLayouts = [];
    for (var i=0; i < genArray.length; i++) {
        // The size for packing is currently based on last boundary circle size
        nodeLayouts.push( d3.layout.pack().size([FV.genFoci[i].radius * 2, FV.height]).padding(10)
                .value( function(d) { return 1; })
                .nodes( genArray[i]));
    }
    return nodeLayouts;
}

// Update position of circles
function update_view( nodeLayouts) {
    set_scale_foci( nodeLayouts);
    // Update the translation for each generation based on any change in genFoci and radii
    for (var i=0; i < nodeLayouts.length; i++) {
        d3.select("#g" + i).attr("transform","translate(" + FV.genFoci[i].dx + ", " + FV.genFoci[i].dy + ")" );
    }
    // Go through each generation in nodeLayout
    for (var i=0; i < nodeLayouts.length; i++) {
        d3.selectAll(".gen" + i).data(nodeLayouts[i], function(d) { return d.mouseId;})
                .transition().delay(700 * Math.pow(i, 1.5)).duration(1400 * Math.pow(i, 1.5))
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; })
                .attr("r", function(d) { return FV.fit_scale(d.r); });
    }
}

// The parameter color_fxn is a function with one parameter - the node data
function update_color( color_fxn) {
    d3.selectAll(".node").transition()
            .style("fill", function(d, i) {
                if (d.depth == 0) { return "rgba(255,255,255,0)"; }
                else { return color_fxn(d); }
            });
}

$(document).ready( function() {
    create_initial_view( initialize() );
    FV.formattedData.add_format( "genderCheck", create_gender_format);
    update_view( layout_generations( FV.formattedData.get_hierarchy() ) );

}); //end document ready

</script>

<div id="filters" style="background-color: #EFEFFA">
<table cellspacing="10">
    <tr><td>
        <label><b>Color By: </b></label>
        <select id="selectColorGroup">
            <option value="gender" selected="true">Gender</option>
            <option value="genotype">Genotype</option>
        </select>
    </td>
    <td>
        <label><b>Circle Size By: </b></label>
        <select id="selectSizeGroup">
            <option value="uniform">Uniform</option>
            <option value="children">Number of children</option>
        </select>
    </td>
    <td>
        <label><b>Group By: </b></label>
        <input type="checkbox" id="genderCheck" value="gender" checked="true">Gender
    </td>
    <td>
        <input type="checkbox" id="litterCheck" value="litter">Litter
    </td>
    </tr>
    <tr id="geneSelector" style="display:none"><td>
        <label>LEF1</label><br>
        <input type="checkbox" name="LEF1" value="+/-">+/-<br>
        <input type="checkbox" name="LEF1" value="-/-">-/-<br>
        <input type="checkbox" name="LEF1" value="WT">WT<br>
        <input type="checkbox" name="LEF1" value="NA">NA<br>
    </td><td>
        <label>RANKL</label><br>
        <input type="checkbox" name="RANKL" value="+/-">+/-<br>
        <input type="checkbox" name="RANKL" value="-/-">-/-<br>
        <input type="checkbox" name="RANKL" value="WT">WT<br>
        <input type="checkbox" name="RANKL" value="NA">NA<br>
    </td><td>
        <label>PTHrP</label><br>
        <input type="checkbox" name="PTHrP" value="+/-">+/-<br>
        <input type="checkbox" name="PTHrP" value="-/-">-/-<br>
        <input type="checkbox" name="PTHrP" value="WT">WT<br>
        <input type="checkbox" name="PTHrp" value="NA">NA<br>
    </td></tr>
</table>
</div>

<div id="graph"></div>

</body>
</html>